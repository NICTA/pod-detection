# Autogenerated from a Treetop grammar. Edits may be lost.


module StudTimeFormat
  include Treetop::Runtime

  def root
    @root ||= :format
  end

  module Format0
    def compile
      return %Q<lambda do |t|
        return [ 
          #{elements.collect(&:compile).join(",\n          ")} 
        ].join("")
      end>
    end
  end

  def _nt_format
    start_index = index
    if node_cache[:format].has_key?(index)
      cached = node_cache[:format][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_time
      if r2
        r1 = r2
      else
        r3 = _nt_text
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    r0.extend(Format0)

    node_cache[:format][start_index] = r0

    r0
  end

  def _nt_time
    start_index = index
    if node_cache[:time].has_key?(index)
      cached = node_cache[:time][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_era
    if r1
      r0 = r1
    else
      r2 = _nt_century_of_era
      if r2
        r0 = r2
      else
        r3 = _nt_year_of_era
        if r3
          r0 = r3
        else
          r4 = _nt_weekyear
          if r4
            r0 = r4
          else
            r5 = _nt_week_of_weekyear
            if r5
              r0 = r5
            else
              r6 = _nt_day_of_week_number
              if r6
                r0 = r6
              else
                r7 = _nt_day_of_week_text
                if r7
                  r0 = r7
                else
                  r8 = _nt_year
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_day_of_year
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_month_of_year
                      if r10
                        r0 = r10
                      else
                        r11 = _nt_day_of_month
                        if r11
                          r0 = r11
                        else
                          r12 = _nt_halfday_of_day
                          if r12
                            r0 = r12
                          else
                            r13 = _nt_hour_of_halfday
                            if r13
                              r0 = r13
                            else
                              r14 = _nt_clockhour_of_halfday
                              if r14
                                r0 = r14
                              else
                                r15 = _nt_hour_of_day
                                if r15
                                  r0 = r15
                                else
                                  r16 = _nt_clockhour_of_day
                                  if r16
                                    r0 = r16
                                  else
                                    r17 = _nt_minute_of_hour
                                    if r17
                                      r0 = r17
                                    else
                                      r18 = _nt_second_of_minute
                                      if r18
                                        r0 = r18
                                      else
                                        r19 = _nt_fraction_of_second
                                        if r19
                                          r0 = r19
                                        else
                                          r20 = _nt_time_zone_text
                                          if r20
                                            r0 = r20
                                          else
                                            r21 = _nt_time_zone_offset_or_id
                                            if r21
                                              r0 = r21
                                            else
                                              @index = i0
                                              r0 = nil
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:time][start_index] = r0

    r0
  end

  def _nt_text
    start_index = index
    if node_cache[:text].has_key?(index)
      cached = node_cache[:text][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_string
    if r1
      r0 = r1
    else
      r2 = _nt_symbol
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:text][start_index] = r0

    r0
  end

  module String0
    def content
      elements[1]
    end

  end

  module String1
    def compile
      if content.text_value.length == 0
        return %Q<"'">
      else
        return %Q<"#{content.text_value}">
      end
    end
  end

  def _nt_string
    start_index = index
    if node_cache[:string].has_key?(index)
      cached = node_cache[:string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("'", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("'")
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[^\']', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?("'", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("'")
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(String0)
      r0.extend(String1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:string][start_index] = r0

    r0
  end

  module Symbol0
    def compile
      return %<"#{text_value}">
    end
  end

  def _nt_symbol
    start_index = index
    if node_cache[:symbol].has_key?(index)
      cached = node_cache[:symbol][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[^A-Za-z\']', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Symbol0)
    end

    node_cache[:symbol][start_index] = r0

    r0
  end

  module QuoteChar0
    def compile
      return %Q("'")
    end
  end

  def _nt_quote_char
    start_index = index
    if node_cache[:quote_char].has_key?(index)
      cached = node_cache[:quote_char][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("''", false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      r0.extend(QuoteChar0)
      @index += 2
    else
      terminal_parse_failure("''")
      r0 = nil
    end

    node_cache[:quote_char][start_index] = r0

    r0
  end

  def _nt_era
    start_index = index
    if node_cache[:era].has_key?(index)
      cached = node_cache[:era][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("G", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("G")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:era][start_index] = r0

    r0
  end

  module CenturyOfEra0
    def compile
      # TODO(sissel): support eras? I don't really care myself.
      return "AD"
    end
  end

  def _nt_century_of_era
    start_index = index
    if node_cache[:century_of_era].has_key?(index)
      cached = node_cache[:century_of_era][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("C", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("C")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CenturyOfEra0)
    end

    node_cache[:century_of_era][start_index] = r0

    r0
  end

  module YearOfEra0
    def compile
      # No 'era' support, so year is just year.
      return case text_value.length
        when 2 then "t.year % 100"
        else "t.year"
      end
    end
  end

  def _nt_year_of_era
    start_index = index
    if node_cache[:year_of_era].has_key?(index)
      cached = node_cache[:year_of_era][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    s1, i1 = [], index
    loop do
      if has_terminal?("Y", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("Y")
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    if r1
      r0 = r1
      r0.extend(YearOfEra0)
    else
      r3 = _nt_weekyear
      if r3
        r0 = r3
        r0.extend(YearOfEra0)
      else
        r4 = _nt_year
        if r4
          r0 = r4
          r0.extend(YearOfEra0)
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:year_of_era][start_index] = r0

    r0
  end

  def _nt_weekyear
    start_index = index
    if node_cache[:weekyear].has_key?(index)
      cached = node_cache[:weekyear][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("x", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("x")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:weekyear][start_index] = r0

    r0
  end

  module WeekOfWeekyear0
    def compile
      return "(t.yday / 7) + 1"
    end
  end

  def _nt_week_of_weekyear
    start_index = index
    if node_cache[:week_of_weekyear].has_key?(index)
      cached = node_cache[:week_of_weekyear][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("w", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("w")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(WeekOfWeekyear0)
    end

    node_cache[:week_of_weekyear][start_index] = r0

    r0
  end

  module DayOfWeekNumber0
    def compile
      return "t.wday"
    end
  end

  def _nt_day_of_week_number
    start_index = index
    if node_cache[:day_of_week_number].has_key?(index)
      cached = node_cache[:day_of_week_number][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("e", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("e")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(DayOfWeekNumber0)
    end

    node_cache[:day_of_week_number][start_index] = r0

    r0
  end

  module DayOfWeekText0
    def compile
      if text_value.length < 4
        return %Q<t.strftime("%a")> 
      end
      return %Q<t.strftime("%A")>
    end
  end

  def _nt_day_of_week_text
    start_index = index
    if node_cache[:day_of_week_text].has_key?(index)
      cached = node_cache[:day_of_week_text][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("E", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("E")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(DayOfWeekText0)
    end

    node_cache[:day_of_week_text][start_index] = r0

    r0
  end

  def _nt_year
    start_index = index
    if node_cache[:year].has_key?(index)
      cached = node_cache[:year][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("y", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("y")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:year][start_index] = r0

    r0
  end

  module DayOfYear0
    def compile
      return %Q<t.yday>
    end
  end

  def _nt_day_of_year
    start_index = index
    if node_cache[:day_of_year].has_key?(index)
      cached = node_cache[:day_of_year][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("D", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("D")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(DayOfYear0)
    end

    node_cache[:day_of_year][start_index] = r0

    r0
  end

  module MonthOfYear0
    def compile
      return case text_value.length
        when 1..2 then %Q<sprintf("%0#{text_value.length}d", t.month)>
        when 3 then %Q<t.strftime("%b")>
        else %Q<t.strftime("%B")>
      end
    end
  end

  def _nt_month_of_year
    start_index = index
    if node_cache[:month_of_year].has_key?(index)
      cached = node_cache[:month_of_year][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("M", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("M")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MonthOfYear0)
    end

    node_cache[:month_of_year][start_index] = r0

    r0
  end

  module DayOfMonth0
    def compile
      return %Q<t.strftime("%0#{text_value.length}d")>
    end
  end

  def _nt_day_of_month
    start_index = index
    if node_cache[:day_of_month].has_key?(index)
      cached = node_cache[:day_of_month][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("d", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("d")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(DayOfMonth0)
    end

    node_cache[:day_of_month][start_index] = r0

    r0
  end

  module HalfdayOfDay0
    def compile
      return %Q<t.strftime("%p")>
    end
  end

  def _nt_halfday_of_day
    start_index = index
    if node_cache[:halfday_of_day].has_key?(index)
      cached = node_cache[:halfday_of_day][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("a", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("a")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(HalfdayOfDay0)
    end

    node_cache[:halfday_of_day][start_index] = r0

    r0
  end

  module HourOfHalfday0
    def compile
      return %Q<t.strftime("%I")>
    end
  end

  def _nt_hour_of_halfday
    start_index = index
    if node_cache[:hour_of_halfday].has_key?(index)
      cached = node_cache[:hour_of_halfday][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("K", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("K")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(HourOfHalfday0)
    end

    node_cache[:hour_of_halfday][start_index] = r0

    r0
  end

  module ClockhourOfHalfday0
    def compile
      return %Q<sprintf("%0#{text_value.length}d", t.hour / 12)>
    end
  end

  def _nt_clockhour_of_halfday
    start_index = index
    if node_cache[:clockhour_of_halfday].has_key?(index)
      cached = node_cache[:clockhour_of_halfday][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("h", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("h")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClockhourOfHalfday0)
    end

    node_cache[:clockhour_of_halfday][start_index] = r0

    r0
  end

  module HourOfDay0
    def compile
      return %Q<sprintf("%0#{text_value.length}d", t.hour)>
    end
  end

  def _nt_hour_of_day
    start_index = index
    if node_cache[:hour_of_day].has_key?(index)
      cached = node_cache[:hour_of_day][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("H", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("H")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(HourOfDay0)
    end

    node_cache[:hour_of_day][start_index] = r0

    r0
  end

  module ClockhourOfDay0
    def compile
      return %Q<sprintf("%0#{text_value.length}d", t.hour + 1)>
    end
  end

  def _nt_clockhour_of_day
    start_index = index
    if node_cache[:clockhour_of_day].has_key?(index)
      cached = node_cache[:clockhour_of_day][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("k", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("k")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClockhourOfDay0)
    end

    node_cache[:clockhour_of_day][start_index] = r0

    r0
  end

  module MinuteOfHour0
    def compile
      return %Q<sprintf("%0#{text_value.length}d", t.min)>
    end
  end

  def _nt_minute_of_hour
    start_index = index
    if node_cache[:minute_of_hour].has_key?(index)
      cached = node_cache[:minute_of_hour][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("m", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("m")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MinuteOfHour0)
    end

    node_cache[:minute_of_hour][start_index] = r0

    r0
  end

  module SecondOfMinute0
    def compile
      return %Q<sprintf("%0#{text_value.length}d", t.sec)>
    end
  end

  def _nt_second_of_minute
    start_index = index
    if node_cache[:second_of_minute].has_key?(index)
      cached = node_cache[:second_of_minute][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("s", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("s")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SecondOfMinute0)
    end

    node_cache[:second_of_minute][start_index] = r0

    r0
  end

  module FractionOfSecond0
    def compile
      return %Q<sprintf("%0#{text_value.length}d", t.nsec / (10 ** (9 - #{text_value.length})))>
    end
  end

  def _nt_fraction_of_second
    start_index = index
    if node_cache[:fraction_of_second].has_key?(index)
      cached = node_cache[:fraction_of_second][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("S", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("S")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FractionOfSecond0)
    end

    node_cache[:fraction_of_second][start_index] = r0

    r0
  end

  def _nt_time_zone_text
    start_index = index
    if node_cache[:time_zone_text].has_key?(index)
      cached = node_cache[:time_zone_text][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("z", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("z")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:time_zone_text][start_index] = r0

    r0
  end

  module TimeZoneOffsetOrId0
    def compile
      return %Q<sprintf("%+05d", t.gmtoff / 36)>
    end
  end

  def _nt_time_zone_offset_or_id
    start_index = index
    if node_cache[:time_zone_offset_or_id].has_key?(index)
      cached = node_cache[:time_zone_offset_or_id][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?("Z", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("Z")
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TimeZoneOffsetOrId0)
    end

    node_cache[:time_zone_offset_or_id][start_index] = r0

    r0
  end

end

class StudTimeFormatParser < Treetop::Runtime::CompiledParser
  include StudTimeFormat
end

